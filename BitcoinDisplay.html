<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Bitcoin Price Display</title>
    <!-- Preconnect links are okay - they don't download fonts, just speed up later connections -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif; /* Default font, overridden by settings */
            background-color: #1C1C1C; /* Default, overridden by settings */
            /* color: set by JS 'otherTextColor' */
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Prevent scrollbars on body */
        }
        .price-container {
            text-align: center;
            width: 100vw;
            max-width: 100vw;
            height: 80vh; /* Main area for the price */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; /* Center price vertically and horizontally */
        }
        .btc-label { /* Style remains, but applies to element in info-container now */
            font-size: 4vh; /* Base size, scaled by JS */
            /* color: set by JS 'otherTextColor' */
            margin-bottom: 0.5vh; /* Match spacing of other info items */
            display: block; /* Default, controlled by JS toggle */
        }
        .price-wrapper {
            width: 100%;
            height: 100%; /* Fill the container */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            margin-bottom: 2vh; /* Space below price */
        }
        .price {
            display: inline-block;
            font-weight: bold;
            white-space: nowrap;
            text-align: center;
            line-height: 1; /* Ensure tight line spacing */
             /* Font size is set dynamically by JS resizePriceToFit */
             letter-spacing: normal; /* Base letter-spacing */
        }
        .price-number {
            /* color: set by JS 'textColor' */
            /* Font size inherited from .price */
        }
        .price-comma {
            /* color: set by JS 'textColor' */
            font-weight: normal; /* Make comma less bold */
            vertical-align: baseline; /* Align comma properly */
            opacity: 0.8; /* Slightly fade comma */
            font-size: 80%; /* Make comma slightly smaller relative to numbers */
        }
        .info-container {
            position: fixed;
             /* User adjusted position */
            bottom: 11px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none; /* Allow clicks through info */
            z-index: 1; /* Ensure it's above background but below buttons/modal */
        }
        .api-name, .timestamp {
            font-size: 4vh; /* Base size, scaled by JS */
            /* color: set by JS 'otherTextColor' */
            margin-bottom: 0.5vh; /* Consistent spacing */
            display: block; /* Default, controlled by JS toggle */
        }

        .status-message {
             position: absolute;
             top: 5px;
             right: 5px;
             font-size: 4vh; /* Base size, scaled by JS */
             /* color: set by JS 'otherTextColor' */
             display: none; /* Hidden by default, shown by JS */
             background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background for readability */
             padding: 2px 8px;
             border-radius: 4px;
             z-index: 50; /* Above content, below settings */
             pointer-events: none;
        }
        .settings-button {
            position: fixed;
            bottom: 20px;
            left: 5px;
            background-color: rgba(100,100,100,0.5);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px; /* Fixed font size for button */
            z-index: 100;
            pointer-events: auto; /* Ensure button is clickable */
        }
        .fullscreen-button {
            position: fixed;
            bottom: 20px;
            right: 5px;
            background-color: rgba(100,100,100,0.5);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px; /* Fixed font size for button */
            z-index: 100;
            pointer-events: auto; /* Ensure button is clickable */
        }

        /* Hide buttons when in fullscreen using pseudo-class */
        :fullscreen .settings-button,
        :fullscreen .fullscreen-button {
            display: none;
        }
        /* Alternative using class (added by JS for potentially better cross-browser/state handling) */
        body.in-fullscreen .settings-button,
        body.in-fullscreen .fullscreen-button {
            display: none;
        }

        .settings-modal {
            position: fixed;
            bottom: 80px; /* Position above button(s) */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(50,50,50,0.9);
            color: white; /* Explicit color for modal text */
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            max-width: 90vw;
            z-index: 200; /* Above everything else */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: none; /* Hidden by default */
            pointer-events: auto; /* Ensure modal is interactive */

            /* --- NEW: Added for mobile scrolling --- */
            max-height: calc(100vh - 120px); /* Limit height (e.g., screen height minus space for buttons and top margin) */
            overflow-y: auto; /* Add vertical scrollbar ONLY if content overflows */
            /* Add some padding at the bottom inside the scroll area */
            padding-bottom: 30px;
            /* --- End NEW --- */
        }
        .settings-modal.visible {
            display: block;
        }
	.settings-modal .settings-option:first-child {
    margin-top: 100px; /* Or use padding-top: 200px; */
}
        .settings-option {
            margin-bottom: 15px;
        }
        .settings-option h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px; /* Fixed font size */
            font-weight: normal;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        .color-options {
            display: flex;
            gap: 10px;
            margin-bottom: 10px; /* Space below color pickers */
            flex-wrap: wrap; /* Allow wrapping */
        }
        .color-picker {
            width: 30px; /* Slightly smaller */
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 0 3px rgba(0,0,0,0.3);
        }
        .color-picker.selected {
            border-color: #f7931a; /* Highlight selected color */
            transform: scale(1.1);
        }
        .font-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns */
            gap: 5px;
            margin: 5px 0;
        }
        .font-preview {
            padding: 5px;
            border: 1px solid #666;
            cursor: pointer;
            text-align: center;
            font-size: 12px; /* Smaller font size for preview */
            border-radius: 3px;
            background-color: rgba(255, 255, 255, 0.1);
            overflow: hidden; /* Prevent long names breaking layout */
            white-space: nowrap;
            text-overflow: ellipsis;
            /* Use a safe font for the preview text itself */
            font-family: Verdana, Geneva, sans-serif;
            position: relative; /* For loading indicator */
        }
        .font-preview.selected {
            background-color: rgba(255,255,255,0.2);
            border-color: #f7931a; /* Highlight selected font */
            font-weight: bold;
        }
        .font-preview .loading-indicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
        }
        /* Style for buttons inside modal */
        .settings-modal button {
            padding: 8px 12px;
            background-color: rgba(100,100,100,0.5);
            color: white;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px; /* Consistent button font size */
        }
        .settings-modal button:hover {
             background-color: rgba(120,120,120,0.6);
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex-grow: 1; /* Allow slider to take available space */
            cursor: pointer;
            height: 5px;
            background: #555;
            border-radius: 5px;
            appearance: none; /* Override default look */
        }
        input[type="range"]::-webkit-slider-thumb { /* Chrome/Safari */
            appearance: none;
            width: 15px;
            height: 15px;
            background: #ccc;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb { /* Firefox */
            width: 15px;
            height: 15px;
            background: #ccc;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .slider-container span {
            min-width: 40px; /* Ensure space for percentage value */
            text-align: right;
            font-size: 14px;
        }
        .toggle-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .toggle-option {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toggle-option label {
            font-size: 14px;
            cursor: pointer;
            flex-grow: 1;
        }
         .toggle-option input[type="checkbox"] {
             cursor: pointer;
         }
        input[type="color"] {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
            pointer-events: none;
        }

        /* --- Custom Font Spacing Rule --- */
        body.font-anton-active .price {
            letter-spacing: 2px; /* Adjust as needed */
        }

    </style>
</head>
<body>
    <div class="price-container">
        <div class="price-wrapper">
            <div class="price" id="btcPrice">---</div>
        </div>
    </div>

    <div class="info-container">
        <div class="btc-label" id="btcLabel">BTC</div>
        <div class="api-name" id="apiName"></div>
        <div class="timestamp" id="lastUpdated">Updating...</div>
    </div>

    <div class="status-message" id="statusInfo"></div>

    <button id="settingsButton" class="settings-button">⚙️ Settings</button>
    <button id="fullscreenButton" class="fullscreen-button">Fullscreen</button>


    <div id="settingsModal" class="settings-modal">
        <div class="settings-option">
            <h3>Price Color</h3>
            <div class="color-options" id="textColorOptions">
                <div class="color-picker" title="Bitcoin Orange" data-color="#f7931a" style="background-color: #f7931a;"></div>
                <div class="color-picker" title="White" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <div class="color-picker" title="Green" data-color="#46FE43" style="background-color: #46FE43;"></div>
                <input type="color" id="customTextColor" value="#f7931a">
                <button id="customTextColorBtn" title="Select custom color">Custom</button>
            </div>
        </div>
        <div class="settings-option">
            <h3>Background Color</h3>
             <!-- Using user's updated order -->
            <div class="color-options" id="bgColorOptions">
                <div class="color-picker" title="Dark Gray" data-color="#1C1C1C" style="background-color: #1C1C1C;"></div>
                <div class="color-picker" title="Black" data-color="#000000" style="background-color: #000000;"></div>
                <div class="color-picker" title="White" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <input type="color" id="customBgColor" value="#1C1C1C"> <!-- Default value matches script -->
                <button id="customBgColorBtn" title="Select custom color">Custom</button>
            </div>
        </div>

        <div class="settings-option">
            <h3>Other Text Color</h3>
            <div class="color-options" id="otherTextColorOptions">
                <div class="color-picker" title="Medium Gray" data-color="#666666" style="background-color: #666666;"></div>
                <div class="color-picker" title="White" data-color="#ffffff" style="background-color: #ffffff;"></div>
                <div class="color-picker" title="Light Gray" data-color="#aaaaaa" style="background-color: #aaaaaa;"></div>
                <input type="color" id="customOtherTextColor" value="#666666">
                <button id="customOtherTextColorBtn" title="Select custom color">Custom</button>
            </div>
        </div>

        <div class="settings-option">
            <h3>Price Font Size (Scale)</h3>
            <div class="slider-container">
                <input type="range" id="priceFontSize" min="10" max="200" value="100" title="Adjust relative size">
                <span id="priceFontSizeValue">100%</span>
            </div>
        </div>
        <div class="settings-option">
            <h3>Other Font Size (Scale)</h3>
            <div class="slider-container">
                <input type="range" id="otherFontSize" min="20" max="150" value="50" title="Adjust relative size">
                <span id="otherFontSizeValue">50%</span>
            </div>
        </div>
        <div class="settings-option">
            <h3>Font Selection</h3>
            <div id="fontOptions" class="font-grid">
                 <!-- Font previews go here -->
            </div>
        </div>
        <div class="settings-option">
            <h3>Display Options</h3>
            <div class="toggle-container">
                <div class="toggle-option">
                    <input type="checkbox" id="showUpdateTime" checked>
                    <label for="showUpdateTime">Show Update Time</label>
                </div>
                <div class="toggle-option">
                    <input type="checkbox" id="showApiName" checked>
                    <label for="showApiName">Show API Name</label>
                </div>
                <div class="toggle-option">
                    <input type="checkbox" id="showBtcLabel" checked>
                    <label for="showBtcLabel">Show BTC Label</label>
                </div>
            </div>
        </div>
    </div>

    <script>
    // CORE DISPLAY LOGIC (IIFE 1) - Unchanged from previous version
    (function() {
        window.APIs = [
            {name: "Coinbase", type: "fetch", url: "https://api.coinbase.com/v2/prices/BTC-USD/spot", updateFrequency: 5000, displayFrequency: "5 sec", processData: function(data) { return parseFloat(data?.data?.amount); }},
            {name: "Bitstamp", type: "fetch", url: "https://www.bitstamp.net/api/v2/ticker/btcusd/", updateFrequency: 5000, displayFrequency: "5 sec", processData: function(data) { return parseFloat(data?.last); }},
            {name: "Gemini", type: "fetch", url: "https://api.gemini.com/v1/pubticker/btcusd", updateFrequency: 7000, displayFrequency: "7 sec", processData: function(data) { return parseFloat(data?.last); }},
            {name: "Bittrex", type: "fetch", url: "https://api.bittrex.com/v3/markets/BTC-USD/ticker", updateFrequency: 12000, displayFrequency: "12 sec", processData: function(data) { return parseFloat(data?.lastTradeRate); }},
            {name: "Bitfinex", type: "fetch", url: "https://api-pub.bitfinex.com/v2/ticker/tBTCUSD", updateFrequency: 12000, displayFrequency: "12 sec", processData: function(data) { return Array.isArray(data) ? data[6] : undefined; }},
            {name: "Kraken", type: "fetch", url: "https://api.kraken.com/0/public/Ticker?pair=XBTUSD", updateFrequency: 15000, displayFrequency: "15 sec", processData: function(data) { return parseFloat(data?.result?.XXBTZUSD?.c?.[0]); }},
            {name: "Blockchain.info", type: "fetch", url: "https://blockchain.info/ticker?cors=true", updateFrequency: 15000, displayFrequency: "15 sec", processData: function(data) { return data?.USD?.last; }},
            {name: "CoinGecko", type: "fetch", url: "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd", updateFrequency: 45000, displayFrequency: "45 sec", processData: function(data) { return data?.bitcoin?.usd; }},
            {name: "Coindesk", type: "jsonp", url: "https://api.coindesk.com/v1/bpi/currentprice.json", updateFrequency: 60000, displayFrequency: "60 sec", processData: function(data) { return data?.bpi?.USD?.rate_float; }}
        ];

        window.currentApiIndex = 0;
        let lastSuccessfulPrice = null;
        let lastSuccessfulApiTime = 0;
        let rateLimitedApis = new Set();
        let updateTimer = null;
        let primaryApiCheckTimer = null;
        window.btcDisplaySettings = {};

        function resizePriceToFit(percentage) {
            const priceElement = document.getElementById('btcPrice');
            const priceWrapper = document.querySelector('.price-wrapper');
            if (!priceElement || !priceWrapper || priceWrapper.offsetWidth === 0 || priceWrapper.offsetHeight === 0) {
                 return;
            }
            const maxWidth = priceWrapper.offsetWidth * 0.98;
            const maxHeight = priceWrapper.offsetHeight * 0.98;
            priceElement.style.fontSize = '10px';
            let fontSize = Math.min(window.innerHeight * 0.4, window.innerWidth * 0.15, 500);
            priceElement.style.fontSize = fontSize + 'px';
            let low = 10, high = fontSize * 2;
            let mid;
            for(let i = 0; i < 8; i++) {
                mid = (low + high) / 2;
                priceElement.style.fontSize = mid + 'px';
                if (priceElement.scrollWidth <= maxWidth && priceElement.scrollHeight <= maxHeight) {
                    low = mid;
                } else {
                    high = mid;
                }
            }
            fontSize = low;
            const finalSize = fontSize * (percentage / 100);
            priceElement.style.fontSize = finalSize + 'px';
        }

        function formatPrice(price) {
            if (price === null || typeof price === 'undefined' || isNaN(price)) return `<span class="price-number">---</span>`;
            const roundedPrice = Math.round(Number(price));
            const priceString = roundedPrice.toString();
            let formattedPrice = '';
            const textColor = window.btcDisplaySettings?.textColor || '#f7931a';
            for (let i = 0; i < priceString.length; i++) {
                formattedPrice += `<span class="price-number" style="color: ${textColor};">${priceString[i]}</span>`;
                if ((priceString.length - 1 - i) % 3 === 0 && i !== priceString.length - 1) {
                    formattedPrice += `<span class="price-comma" style="color: ${textColor};">,</span>`;
                }
            }
            return formattedPrice;
        }

        async function fetchWithTimeout(resource, options = {}, timeout = 4000) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
                const response = await fetch(resource, {
                    ...options,
                    signal: controller.signal,
                    cache: 'no-store'
                });
                clearTimeout(id);
                return response;
            } catch (error) {
                clearTimeout(id);
                if (error.name !== 'AbortError') {
                   console.error(`Fetch error for ${resource}:`, error.message);
                }
                throw error;
            }
        }

        async function fetchPriceWithFetch(api) {
            try {
                if (rateLimitedApis.has(api.name)) return null;
                const cacheBuster = `_cb=${Date.now()}`;
                const url = api.url.includes('?') ? `${api.url}&${cacheBuster}` : `${api.url}?${cacheBuster}`;
                const response = await fetchWithTimeout(url, {}, 4000);
                if (!response.ok) {
                     if (response.status === 429 || response.status === 403) {
                         console.warn(`Rate limited: ${api.name}. Adding to temporary block list.`);
                         rateLimitedApis.add(api.name);
                         showStatus(`Rate limited: ${api.name}`, 3000);
                         setTimeout(() => { rateLimitedApis.delete(api.name); console.log(`Unblocked API: ${api.name}`); }, 60000);
                     } else { console.log(`${api.name} API error: Status ${response.status} ${response.statusText}`); }
                     return null;
                }
                const data = await response.json();
                const price = api.processData(data);
                if (price !== undefined && price !== null && !isNaN(parseFloat(price)) && parseFloat(price) > 0) {
                    return parseFloat(price);
                }
                console.log(`${api.name} API error: Invalid price data processed. Raw Data:`, data, "Processed:", price);
                return null;
            } catch (error) { if (error.name !== 'AbortError') { console.log(`${api.name} API fetch/processing error:`, error.message); } return null; }
        }

        function fetchPriceWithJsonp(api) {
            return new Promise((resolve) => {
                if (rateLimitedApis.has(api.name)) return resolve(null);
                const callbackName = 'btcCallback_' + Date.now() + Math.floor(Math.random() * 1000);
                const script = document.createElement('script');
                let timeoutId = null; let scriptAdded = false;
                function cleanup() { clearTimeout(timeoutId); if (script.parentNode && scriptAdded) { try { script.parentNode.removeChild(script); } catch (e) {} } delete window[callbackName]; }
                timeoutId = setTimeout(() => { console.log(`${api.name} JSONP timeout.`); cleanup(); resolve(null); }, 4000);
                window[callbackName] = function(data) { cleanup(); try { const price = api.processData(data); if (price !== undefined && price !== null && !isNaN(parseFloat(price)) && parseFloat(price) > 0) { resolve(parseFloat(price)); } else { console.log(`${api.name} JSONP API error: Invalid price data processed. Raw Data:`, data, "Processed:", price); resolve(null); } } catch (error) { console.log(`${api.name} JSONP processing error:`, error); resolve(null); } };
                script.onerror = function(e) { console.log(`${api.name} JSONP script error:`, e); cleanup(); resolve(null); };
                const cacheBuster = `_=${Date.now()}`; script.src = `${api.url}${api.url.includes('?') ? '&' : '?'}callback=${callbackName}&${cacheBuster}`;
                try { document.body.appendChild(script); scriptAdded = true; } catch(e) { console.error("Error appending JSONP script:", e); cleanup(); resolve(null); }
            });
        }

        let statusTimer = null;
        function showStatus(message, duration = 4000) {
            const statusElement = document.getElementById('statusInfo');
            if (!statusElement) return;
            statusElement.textContent = message; statusElement.style.display = 'block';
            if (statusTimer) clearTimeout(statusTimer);
            statusTimer = setTimeout(() => { statusElement.style.display = 'none'; statusTimer = null; }, duration);
        }
        window.showStatus = showStatus;

        function setUpdateInterval(api) {
            if (updateTimer) clearInterval(updateTimer);
            fetchBitcoinPrice();
            updateTimer = setInterval(fetchBitcoinPrice, api.updateFrequency);
        }

        async function checkForPreferredApi() {
            if (window.currentApiIndex === 0 || APIs.length <= 1) return;
            for (let i = 0; i < window.currentApiIndex; i++) {
                const api = APIs[i];
                if (rateLimitedApis.has(api.name)) continue;
                let price = null;
                try { price = api.type === "jsonp" ? await fetchPriceWithJsonp(api) : await fetchPriceWithFetch(api); } catch (e) { console.error(`Error during preferred API check for ${api.name}:`, e); }
                if (price !== null) {
                    console.log(`Switching back to faster API: ${api.name}`); showStatus(`Switched to faster API: ${api.name}`, 3000);
                    window.currentApiIndex = i; updatePriceDisplay(price, api); setUpdateInterval(api); return;
                }
            }
        }

        function updatePriceDisplay(price, api) {
            const priceElement = document.getElementById('btcPrice');
            const timestampElement = document.getElementById('lastUpdated');
            const apiNameElement = document.getElementById('apiName');
            const btcLabelElement = document.getElementById('btcLabel');

            if (!priceElement) { console.error("Price element not found."); return; }
            lastSuccessfulPrice = price; lastSuccessfulApiTime = Date.now();
            priceElement.innerHTML = formatPrice(price);
            if (window.btcDisplaySettings && window.btcDisplaySettings.priceFontSize) { resizePriceToFit(window.btcDisplaySettings.priceFontSize); } else { resizePriceToFit(100); }
            const now = new Date();
            if (timestampElement) { if (window.btcDisplaySettings && window.btcDisplaySettings.showUpdateTime) { timestampElement.textContent = `Updated: ${now.toLocaleTimeString()}`; timestampElement.style.display = 'block'; } else { timestampElement.style.display = 'none'; } }
            if (apiNameElement) { if (window.btcDisplaySettings && window.btcDisplaySettings.showApiName) { apiNameElement.textContent = api.name; apiNameElement.style.display = 'block'; } else { apiNameElement.style.display = 'none'; } }
            if (btcLabelElement) { btcLabelElement.style.display = (window.btcDisplaySettings && window.btcDisplaySettings.showBtcLabel) ? 'block' : 'none'; }
        }

        async function fetchBitcoinPrice() {
            const now = Date.now(); let foundPrice = false; let price = null; let apiUsed = null;
            for (let i = 0; i < APIs.length; i++) {
                const apiIndex = (window.currentApiIndex + i) % APIs.length; const currentApi = APIs[apiIndex]; apiUsed = currentApi;
                price = null;
                try { if (currentApi.type === "jsonp") { price = await fetchPriceWithJsonp(currentApi); } else { price = await fetchPriceWithFetch(currentApi); } } catch (e) { console.error(`Unhandled error fetching from ${currentApi.name}:`, e); price = null; }
                if (price !== null) {
                    if (i > 0) { console.log(`Switched to fallback API: ${currentApi.name}`); showStatus(`Using fallback API: ${currentApi.name}`, 3000); window.currentApiIndex = apiIndex; clearInterval(updateTimer); updateTimer = setInterval(fetchBitcoinPrice, currentApi.updateFrequency); }
                    updatePriceDisplay(price, currentApi); foundPrice = true; break;
                }
            }
            if (!foundPrice) {
                 console.warn("All APIs failed to return a price in this cycle."); const timestampElement = document.getElementById('lastUpdated');
                 if(apiUsed){ updatePriceDisplay(null, apiUsed); } // Show '---'
                 if (timestampElement && window.btcDisplaySettings && window.btcDisplaySettings.showUpdateTime) { if (lastSuccessfulPrice !== null) { timestampElement.textContent = `Update failed. Last: ${new Date(lastSuccessfulApiTime).toLocaleTimeString()}`; } else { timestampElement.textContent = "Connecting..."; } timestampElement.style.display = 'block'; }
                 if (lastSuccessfulPrice !== null && (now - lastSuccessfulApiTime > 120000) && window.currentApiIndex !== 0) { console.log("Prolonged API failure, resetting to primary API."); showStatus("Connection issues - resetting API", 4000); window.currentApiIndex = 0; setUpdateInterval(APIs[0]); }
            }
        }

        function initializeCoreDisplay() {
             if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', runInitialization); } else { runInitialization(); }
        }

        let coreInitialized = false;
        function runInitialization() {
            if (coreInitialized) return; coreInitialized = true; window.coreInitialized = true;
            console.log("Running Core Initialization...");
            window.currentApiIndex = 0; const initialApi = APIs[window.currentApiIndex];
            setUpdateInterval(initialApi);
            if (primaryApiCheckTimer) clearInterval(primaryApiCheckTimer); primaryApiCheckTimer = setInterval(checkForPreferredApi, 180000);
            let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if (window.btcDisplaySettings && window.btcDisplaySettings.priceFontSize) { resizePriceToFit(window.btcDisplaySettings.priceFontSize); } else { resizePriceToFit(100); } }, 150); });
            window.btcPriceDisplay = { resizePriceToFit: (percentage) => resizePriceToFit(percentage) };

            // --- Fullscreen Logic with Prefixes ---
            const fullscreenButton = document.getElementById('fullscreenButton');

            function enterFullscreen(element) {
                try {
                    if (element.requestFullscreen) { element.requestFullscreen(); }
                    else if (element.webkitRequestFullscreen) { element.webkitRequestFullscreen(); }
                    else if (element.mozRequestFullScreen) { element.mozRequestFullScreen(); }
                    else if (element.msRequestFullscreen) { element.msRequestFullscreen(); }
                    else { console.warn("Fullscreen API is not supported."); showStatus("Fullscreen not supported", 3000); }
                } catch (err) { console.error(`Error enabling full-screen: ${err.message} (${err.name})`); showStatus("Could not enter fullscreen", 3000); }
            }

            function exitFullscreen() {
                 try {
                    if (document.exitFullscreen) { document.exitFullscreen(); }
                    else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); }
                    else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); }
                    else if (document.msExitFullscreen) { document.msExitFullscreen(); }
                    else { console.warn("Exit Fullscreen API not supported."); }
                 } catch (err) { console.error(`Error exiting full-screen: ${err.message} (${err.name})`); }
            }

            if (fullscreenButton) {
                fullscreenButton.addEventListener('click', () => {
                    if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                        enterFullscreen(document.documentElement);
                    }
                });
            } else { console.error("Fullscreen button not found!"); }

            function fullscreenExitHandler() {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                     exitFullscreen();
                 }
            }

            function handleFullscreenChange() {
                 const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
                if (isFullscreen) {
                    console.log("Entered fullscreen");
                    document.body.classList.add('in-fullscreen');
                    document.documentElement.addEventListener('click', fullscreenExitHandler, { once: true, capture: true });
                } else {
                    console.log("Exited fullscreen");
                    document.body.classList.remove('in-fullscreen');
                }
            }

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
            // --- End Fullscreen Logic ---

            console.log("Core Display Initialized."); document.dispatchEvent(new CustomEvent('coreDisplayReady'));
        }
        initializeCoreDisplay();
    })();


    // SETTINGS LOGIC (IIFE 2)
    (function() {
        console.log("Initializing Settings Logic...");

        const availableFonts = [
            { name: 'Arial', family: 'Arial, sans-serif', googleSegment: null, loaded: true },
            { name: 'Anton', family: "'Anton', sans-serif", googleSegment: 'Anton', loaded: false },
            { name: 'Archivo Black', family: "'Archivo Black', sans-serif", googleSegment: 'Archivo+Black', loaded: false },
            { name: 'Arvo', family: "'Arvo', serif", googleSegment: 'Arvo:wght@400', loaded: false },
            { name: 'Chakra Petch', family: "'Chakra Petch', sans-serif", googleSegment: 'Chakra+Petch:wght@400', loaded: false },
            { name: 'DM Serif Display', family: "'DM Serif Display', serif", googleSegment: 'DM+Serif+Display:wght@400', loaded: false },
            { name: 'Londrina Shadow', family: "'Londrina Shadow', cursive", googleSegment: 'Londrina+Shadow', loaded: false },
            { name: 'Noto Serif', family: "'Noto Serif', serif", googleSegment: 'Noto+Serif:wght@400', loaded: false },
            { name: 'Press Start 2P', family: "'Press Start 2P', cursive", googleSegment: 'Press+Start+2P', loaded: false },
            { name: 'Red Hat Display', family: "'Red Hat Display', sans-serif", googleSegment: 'Red+Hat+Display:wght@400', loaded: false },
            { name: 'Roboto', family: "'Roboto', sans-serif", googleSegment: 'Roboto:wght@400', loaded: false },
            { name: 'UnifrakturMaguntia', family: "'UnifrakturMaguntia', cursive", googleSegment: 'UnifrakturMaguntia', loaded: false }
        ];
        const loadedFontLinks = new Set();

        // --- UPDATED Default Background Color ---
        const defaultSettings = {
            textColor: '#f7931a',
            backgroundColor: '#1C1C1C', // Changed default background
            otherTextColor: '#666666',
            priceFontSize: 100,
            otherFontSize: 50,
            fontFamily: availableFonts[0].family,
            showUpdateTime: false,
            showApiName: true,
            showBtcLabel: true
        };

        let settings = { ...defaultSettings };
        window.btcDisplaySettings = settings;
        let settingsInitialized = false;

        function initializeSettings() {
            if (settingsInitialized) return;
            settingsInitialized = true;
            try {
                console.log("Loading and applying settings...");
                loadSavedSettings();
                setupSettingsUI();
                applySettings(); // Apply loaded or default settings
                console.log('Settings initialized successfully');
            } catch (error) {
                console.error('Error initializing settings:', error);
                settings = { ...defaultSettings }; // Fallback to defaults on error
                window.btcDisplaySettings = settings;
                applySettings();
            }
        }

        function saveSetting(key, value) {
            if (key in defaultSettings) {
                try { localStorage.setItem(`btcDisplay_${key}`, value); } catch (e) { console.error(`Error saving setting ${key}:`, e); if (window.showStatus) { window.showStatus("Error saving settings", 3000); } }
            } else {
                console.warn(`Attempted to save unknown setting: ${key}`);
            }
        }

        function loadSavedSettings() {
            console.log("Loading saved settings...");
            Object.keys(defaultSettings).forEach(key => {
                const savedValue = localStorage.getItem(`btcDisplay_${key}`);
                if (savedValue !== null) {
                    // Ensure loaded value type matches default type
                    if (typeof defaultSettings[key] === 'boolean') settings[key] = (savedValue === 'true');
                    else if (typeof defaultSettings[key] === 'number') settings[key] = isNaN(parseInt(savedValue, 10)) ? defaultSettings[key] : parseInt(savedValue, 10);
                    else settings[key] = savedValue; // Strings (colors, font family)
                } else {
                    // If no saved value, ensure current setting is the default
                    settings[key] = defaultSettings[key];
                }
            });
             // Validate font family exists
             if (!availableFonts.some(f => f.family === settings.fontFamily)) {
                 settings.fontFamily = defaultSettings.fontFamily; // Use default font
                 console.warn("Saved font not found, reverting to default.");
             }
            window.btcDisplaySettings = settings;
        }

        // Using the updated applySettings function with letter-spacing logic
        function applySettings() {
            // console.log("Applying settings:", settings);
            try {
                // --- Apply Background Color to Body ---
                document.body.style.backgroundColor = settings.backgroundColor;

                const otherColorTargets = [ document.body, document.querySelector('.btc-label'), document.querySelector('.api-name'), document.querySelector('.timestamp'), document.querySelector('.status-message') ];
                otherColorTargets.forEach(el => { if (el) { el.style.color = settings.otherTextColor; } });
                document.querySelectorAll('.price-number, .price-comma').forEach(el => { el.style.color = settings.textColor; });

                // --- Apply Font Family and Spacing ---
                document.body.style.fontFamily = settings.fontFamily;

                // Remove any previous font-specific spacing classes first
                document.body.classList.remove('font-anton-active'); // Add more classes here if needed for other fonts

                // Check if the currently selected font is Anton and add the class if it is
                const antonFont = availableFonts.find(f => f.name === 'Anton');
                if (antonFont && settings.fontFamily === antonFont.family) {
                    document.body.classList.add('font-anton-active');
                }

                // Resize price based on scale setting
                if (window.btcPriceDisplay?.resizePriceToFit) { window.btcPriceDisplay.resizePriceToFit(settings.priceFontSize); } else { console.warn("resizePriceToFit not available yet."); }

                // Apply other font size scale
                const baseOtherFontSizeVh = 4; const otherFontScale = (settings.otherFontSize / 50); const newOtherSizeVh = baseOtherFontSizeVh * otherFontScale;
                const otherFontTargets = [ document.querySelector('.btc-label'), document.querySelector('.api-name'), document.querySelector('.timestamp'), document.querySelector('.status-message') ];
                otherFontTargets.forEach(el => { if (el) { el.style.fontSize = `${newOtherSizeVh}vh`; } });

                // Apply visibility settings
                document.getElementById('lastUpdated').style.display = settings.showUpdateTime ? 'block' : 'none';
                document.getElementById('apiName').style.display = settings.showApiName ? 'block' : 'none';
                document.getElementById('btcLabel').style.display = settings.showBtcLabel ? 'block' : 'none';

                // Update API name text if visible and core is ready
                if (settings.showApiName && window.APIs && typeof window.currentApiIndex !== 'undefined') {
                     const currentApi = window.APIs[window.currentApiIndex];
                     if (currentApi) {
                         const apiNameElement = document.getElementById('apiName');
                         if (apiNameElement) apiNameElement.textContent = currentApi.name;
                     }
                }

                updateSettingsUI(); // Update modal UI to reflect current settings
            } catch (e) { console.error('Error applying settings:', e); }
        }


        function updateSettingsUI() {
            if (!settingsInitialized) return;
            try {
                 function updateColorUI(optionsId, customInputId, settingKey) {
                     const container = document.getElementById(optionsId); const customInput = document.getElementById(customInputId);
                     if (container) { container.querySelectorAll('.color-picker').forEach(picker => { picker.classList.toggle('selected', picker.dataset.color.toLowerCase() === settings[settingKey].toLowerCase()); }); }
                     if (customInput) { customInput.value = settings[settingKey]; }
                 }
                 updateColorUI('textColorOptions', 'customTextColor', 'textColor'); updateColorUI('bgColorOptions', 'customBgColor', 'backgroundColor'); updateColorUI('otherTextColorOptions', 'customOtherTextColor', 'otherTextColor');

                const priceFontSizeSlider = document.getElementById('priceFontSize'); const priceFontSizeValue = document.getElementById('priceFontSizeValue'); if (priceFontSizeSlider) priceFontSizeSlider.value = settings.priceFontSize; if (priceFontSizeValue) priceFontSizeValue.textContent = settings.priceFontSize + '%';
                const otherFontSizeSlider = document.getElementById('otherFontSize'); const otherFontSizeValue = document.getElementById('otherFontSizeValue'); if (otherFontSizeSlider) otherFontSizeSlider.value = settings.otherFontSize; if (otherFontSizeValue) otherFontSizeValue.textContent = settings.otherFontSize + '%';

                 const fontOptionsDiv = document.getElementById('fontOptions');
                 if(fontOptionsDiv){
                     fontOptionsDiv.querySelectorAll('.font-preview').forEach(preview => {
                         preview.classList.toggle('selected', preview.dataset.family === settings.fontFamily);
                     });
                 }

                const showUpdateTimeCheckbox = document.getElementById('showUpdateTime');
                const showApiNameCheckbox = document.getElementById('showApiName');
                const showBtcLabelCheckbox = document.getElementById('showBtcLabel');

                if(showUpdateTimeCheckbox) showUpdateTimeCheckbox.checked = settings.showUpdateTime;
                if(showApiNameCheckbox) showApiNameCheckbox.checked = settings.showApiName;
                if(showBtcLabelCheckbox) showBtcLabelCheckbox.checked = settings.showBtcLabel;

            } catch (e) { console.error('Error updating settings UI:', e); }
        }

        function loadGoogleFont(font, previewElement) {
            if (!font || !font.googleSegment || font.loaded) {
                 return Promise.resolve();
            }
            const fontUrl = `https://fonts.googleapis.com/css2?family=${font.googleSegment}&display=swap`;
             if (loadedFontLinks.has(fontUrl)) {
                 font.loaded = true;
                 return Promise.resolve();
             }
            console.log(`Loading font: ${font.name}`);
            const indicator = document.createElement('div');
            indicator.className = 'loading-indicator';
            indicator.textContent = '...';
            if (previewElement) previewElement.appendChild(indicator);

            return new Promise((resolve, reject) => {
                const link = document.createElement('link');
                link.rel = 'stylesheet'; link.href = fontUrl; link.id = `google-font-${font.googleSegment.split(':')[0]}`;
                link.onload = () => {
                    console.log(`CSS loaded for ${font.name}. Checking font readiness...`);
                    loadedFontLinks.add(fontUrl); font.loaded = true;
                     document.fonts.load(`1em "${font.family.split(',')[0].replace(/['"]/g, '')}"`)
                        .then(() => {
                             console.log(`Font ${font.name} is ready to use.`);
                             if (previewElement && indicator.parentNode === previewElement) { previewElement.removeChild(indicator); }
                             resolve();
                        }).catch(err => {
                             console.error(`Failed to load font "${font.name}" via Font Loading API:`, err);
                             if (previewElement && indicator.parentNode === previewElement) { previewElement.removeChild(indicator); }
                             reject(err);
                        });
                };
                link.onerror = (err) => {
                    console.error(`Failed to load Google Font CSS: ${fontUrl}`, err);
                    if (previewElement && indicator.parentNode === previewElement) { previewElement.removeChild(indicator); }
                    reject(new Error(`Failed to load CSS for ${font.name}`));
                };
                document.head.appendChild(link);
            });
        }


        function setupSettingsUI() {
            console.log("Setting up Settings UI...");
            const settingsButton = document.getElementById('settingsButton'); const settingsModal = document.getElementById('settingsModal');
            if (!settingsButton || !settingsModal) { console.error("Settings button or modal missing."); return; }

            settingsButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const fullscreenButton = document.getElementById('fullscreenButton');
        
        settingsModal.classList.toggle('visible');
        
        if (settingsModal.classList.contains('visible')) {
            fullscreenButton.style.display = 'none'; // Hide fullscreen button
            updateSettingsUI();
        } else {
            fullscreenButton.style.display = ''; // Restore default display
        }
    });

    document.addEventListener('click', (e) => {
        const fullscreenButton = document.getElementById('fullscreenButton');
        
        if (settingsModal.classList.contains('visible') && 
            e.target !== settingsButton && 
            !settingsModal.contains(e.target) && 
            e.target !== fullscreenButton) {
            
            settingsModal.classList.remove('visible');
            fullscreenButton.style.display = ''; // Restore default display
        }
    }, false);

            function setupColorOption(optionsId, customBtnId, customInputId, settingKey) {
                 const container = document.getElementById(optionsId); const customBtn = document.getElementById(customBtnId); const customInput = document.getElementById(customInputId); if (!container || !customBtn || !customInput) { console.error(`Missing elements for color: ${optionsId}`); return; }
                 container.querySelectorAll('.color-picker').forEach(picker => { picker.addEventListener('click', function(e) { e.stopPropagation(); settings[settingKey] = this.dataset.color; saveSetting(settingKey, settings[settingKey]); applySettings(); }); });
                 customBtn.addEventListener('click', (e) => { e.stopPropagation(); customInput.click(); });
                 customInput.addEventListener('input', function(e) { e.stopPropagation(); settings[settingKey] = this.value; applySettings(); });
                 customInput.addEventListener('change', function(e) { e.stopPropagation(); settings[settingKey] = this.value; saveSetting(settingKey, settings[settingKey]); applySettings(); });
            }
            setupColorOption('textColorOptions', 'customTextColorBtn', 'customTextColor', 'textColor'); setupColorOption('bgColorOptions', 'customBgColorBtn', 'customBgColor', 'backgroundColor'); setupColorOption('otherTextColorOptions', 'customOtherTextColorBtn', 'customOtherTextColor', 'otherTextColor');

             function setupSlider(sliderId, valueDisplayId, settingKey) {
                 const slider = document.getElementById(sliderId); const valueDisplay = document.getElementById(valueDisplayId); if (!slider || !valueDisplay) { console.error(`Missing slider elements: ${sliderId}`); return; }
                 slider.addEventListener('input', function(e) { e.stopPropagation(); const value = parseInt(this.value); settings[settingKey] = value; valueDisplay.textContent = value + '%'; applySettings(); });
                 slider.addEventListener('change', function(e) { e.stopPropagation(); saveSetting(settingKey, settings[settingKey]); });
             }
             setupSlider('priceFontSize', 'priceFontSizeValue', 'priceFontSize'); setupSlider('otherFontSize', 'otherFontSizeValue', 'otherFontSize');

            const fontOptionsDiv = document.getElementById('fontOptions');
            if (fontOptionsDiv) {
                fontOptionsDiv.innerHTML = '';
                availableFonts.forEach((font, index) => {
                    const preview = document.createElement('div');
                    preview.className = 'font-preview'; preview.dataset.family = font.family; preview.dataset.name = font.name; preview.title = font.name; preview.textContent = font.name; preview.style.fontFamily = font.family;
                    if (index === 0) { preview.classList.add('arial-font'); }
                    preview.addEventListener('click', async function(e) {
                        e.stopPropagation();
                        const selectedFontFamily = this.dataset.family; const selectedFontName = this.dataset.name; const fontData = availableFonts.find(f => f.family === selectedFontFamily);
                        if (!fontData) return;
                        const currentlySelected = document.querySelector('.font-preview.selected');
                        if(currentlySelected === this) return;
                        if (fontData.googleSegment && !fontData.loaded) {
                             try {
                                 await loadGoogleFont(fontData, this);
                                 settings.fontFamily = selectedFontFamily; saveSetting('fontFamily', settings.fontFamily); applySettings();
                             } catch (error) { console.error(`Could not apply font ${selectedFontName}:`, error); window.showStatus(`Failed to load font: ${selectedFontName}`, 4000); }
                        } else {
                            settings.fontFamily = selectedFontFamily; saveSetting('fontFamily', settings.fontFamily); applySettings();
                        }
                    });
                    fontOptionsDiv.appendChild(preview);
                });
            } else { console.error("Font options container not found."); }

            function setupToggle(checkboxId, settingKey) {
                const checkbox = document.getElementById(checkboxId); if (!checkbox) { console.warn(`Checkbox not found: ${checkboxId}`); return; }
                const label = checkbox.nextElementSibling;
                 const clickableArea = checkbox.closest('.toggle-option') || checkbox;
                 if (label && label.tagName === 'LABEL' && label.htmlFor === checkboxId) {
                     checkbox.addEventListener('change', function(e) { settings[settingKey] = this.checked; saveSetting(settingKey, settings[settingKey]); applySettings(); });
                 } else {
                    clickableArea.addEventListener('click', function(e) { if (e.target !== checkbox) { e.stopPropagation(); checkbox.checked = !checkbox.checked; checkbox.dispatchEvent(new Event('change')); } }, false);
                    checkbox.addEventListener('change', function(e) { settings[settingKey] = this.checked; saveSetting(settingKey, settings[settingKey]); applySettings(); });
                }
            }
            setupToggle('showUpdateTime', 'showUpdateTime');
            setupToggle('showApiName', 'showApiName');
            setupToggle('showBtcLabel', 'showBtcLabel');

             console.log("Settings UI setup complete.");
        }

        // Initialize settings after core is ready or if it was already ready
        document.addEventListener('coreDisplayReady', initializeSettings);
        if (window.coreInitialized) {
             console.log("Core was ready, initializing settings immediately.");
             initializeSettings();
         }

    })(); // End of settings IIFE

// Create silent audio element for iOS fallback
const silentAudio = new Audio();
silentAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAAwAAAbgAkyQlJSUlJSUlJSUlJSUlJTIyMjIyMjIyMjIyMjIyMjJFRUVFRUVFRUVFRUVFRUVFWVlZWVlZWVlZWVlZWVlZWWZmZmZmZmZmZmZmZmZmZnNzc3Nzc3Nzc3Nzc3Nzc3OGhoaGhoaGhoaGhoaGhoaGk5OTk5OTk5OTk5OTk5OTk6ampqampqampqampqampqa3t7e3t7e3t7e3t7e3t7fExMTExMTExMTExMTExMTM1NTU1NTU1NTU1NTU1NTU1OfU1NTU1NTU1NTU1Nvb29vb29vb29vb29vb29vo6Ojo6Ojo6Ojo6Ojo6Oj19fX19fX19fX19fX19fX1//////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAQKAAAAAAAAAbhNxzH5AAAAAAAAAAAAAAAAAAAA/+MYxAAAAANIAAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDsAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxHYAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxLEAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';
silentAudio.loop = true;

// Variable to track Wake Lock reference
let wakeLock = null;

// This function handles screen wakelock using both methods
async function keepScreenOn() {
  // Try Wake Lock API first (works on most Android browsers)
  if ('wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock active');
      return true;
    } catch (err) {
      console.error('Wake Lock error:', err);
      // Fall through to audio method
    }
  }
  
  // Fallback to audio method (works on iOS)
  try {
    await silentAudio.play();
    console.log('Silent audio playing for screen wake lock');
    return true;
  } catch (e) {
    console.error('Silent audio error:', e);
    return false;
  }
}

// Release wake lock
function releaseWakeLock() {
  // Release Wake Lock if active
  if (wakeLock) {
    wakeLock.release()
      .then(() => {
        console.log('Wake Lock released');
        wakeLock = null;
      })
      .catch(err => {
        console.error('Error releasing wake lock:', err);
      });
  }
  
  // Stop audio
  silentAudio.pause();
  silentAudio.currentTime = 0;
}

// Find the fullscreen toggle function in the original code and modify it
function findAndModifyFullscreenToggle() {
  // Find the existing toggleFullScreen function in the document
  const fullscreenButton = document.getElementById('fullscreenButton');
  
  if (fullscreenButton) {
    // Remove old listeners (to avoid duplicates)
    const newButton = fullscreenButton.cloneNode(true);
    fullscreenButton.parentNode.replaceChild(newButton, fullscreenButton);
    
    // Add our new implementation
    newButton.addEventListener('click', async () => {
      if (!document.fullscreenElement && 
          !document.webkitFullscreenElement && 
          !document.mozFullScreenElement && 
          !document.msFullscreenElement) {
        
        // Going fullscreen
        const rootElement = document.documentElement;
        try {
          // Request fullscreen
          if (rootElement.requestFullscreen) {
            await rootElement.requestFullscreen();
          } else if (rootElement.webkitRequestFullscreen) {
            await rootElement.webkitRequestFullscreen();
          } else if (rootElement.mozRequestFullScreen) {
            await rootElement.mozRequestFullScreen();
          } else if (rootElement.msRequestFullscreen) {
            await rootElement.msRequestFullscreen();
          }
          
          console.log("Entered fullscreen mode");
          document.body.classList.add('in-fullscreen');
          
          // Activate screen wake lock
          await keepScreenOn();
          
        } catch (err) {
          console.error(`Error enabling full-screen: ${err.message}`);
          if (window.showStatus) {
            window.showStatus("Could not enter fullscreen", 3000);
          }
        }
      }
    });
  } else {
    console.error("Fullscreen button not found!");
  }
}

// Add event listener for fullscreen change
function setupFullscreenChangeListener() {
  function handleFullscreenChange() {
    const isFullscreen = !!(
      document.fullscreenElement || 
      document.webkitFullscreenElement || 
      document.mozFullScreenElement || 
      document.msFullscreenElement
    );
    
    if (isFullscreen) {
      console.log("Entered fullscreen");
      document.body.classList.add('in-fullscreen');
    } else {
      console.log("Exited fullscreen");
      document.body.classList.remove('in-fullscreen');
      releaseWakeLock();
    }
  }
  
  // Listen for all browser-specific fullscreen change events
  document.addEventListener('fullscreenchange', handleFullscreenChange);
  document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
  document.addEventListener('mozfullscreenchange', handleFullscreenChange);
  document.addEventListener('MSFullscreenChange', handleFullscreenChange);
}

// Add event listener for visibility change
function setupVisibilityChangeListener() {
  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'hidden') {
      // Browser tab is hidden, release wake lock
      releaseWakeLock();
    } else if (document.visibilityState === 'visible' && 
              (document.fullscreenElement || 
               document.webkitFullscreenElement || 
               document.mozFullScreenElement || 
               document.msFullscreenElement)) {
      // Browser tab is visible again and we're in fullscreen
      await keepScreenOn();
    }
  });
}

// Initialize everything when the page is loaded
function initWakeLock() {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      findAndModifyFullscreenToggle();
      setupFullscreenChangeListener();
      setupVisibilityChangeListener();
    });
  } else {
    findAndModifyFullscreenToggle();
    setupFullscreenChangeListener();
    setupVisibilityChangeListener();
  }
}

// Start initialization
initWakeLock();
	    
    </script>
</body>
</html>
